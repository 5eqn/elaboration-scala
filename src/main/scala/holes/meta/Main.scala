// Meta-related concepts are added.
package holes.meta

type Name = String
type Env = List[Val]
type Types = List[Val]
type Spine = List[Val]

type Index = Int
type Level = Int
type MetaID = Int

enum MetaState:
  case Unsolved
  case Solved(value: Val)

// Meta singleton. Using singleton in Scala3 allows a
// nicer implementation compared to Haskell.
object Meta:
  var map = Map[MetaID, MetaState]()
  var metaCount = -1
  def value(metaID: MetaID): Val = map(metaID) match
    case MetaState.Unsolved      => Val.Meta(metaID)
    case MetaState.Solved(value) => value
  def fresh: Term =
    metaCount += 1
    map += (metaCount -> MetaState.Unsolved)
    Term.Inserted(metaCount)
  def solve(metaID: MetaID, value: Val): Unit =
    map += (metaID -> MetaState.Solved(value))

case class Ctx(
    env: Env,
    types: Types,
    nameMap: Map[Name, Level]
):
  def getVal(name: Name): Val = getVal(nameMap(name))
  def getVal(level: Level): Val = env(envLen - level - 1)
  def getType(name: Name): Val = getType(nameMap(name))
  def getType(level: Level): Val = types(envLen - level - 1)
  def getLevel(name: Name): Level = nameMap(name)
  def add(name: Name, value: Val, ty: Val): Ctx =
    Ctx(value :: env, ty :: types, nameMap + (name -> env.length))
  def add(name: Name, ty: Val): Ctx =
    add(name, Val.Var(env.length), ty)
  def envLen: Int = env.length
  def nextVal: Val = Val.Var(env.length)

object Ctx:
  def empty: Ctx = Ctx(List(), List(), Map())

case class Closure(env: Env, body: Term):
  def apply(arg: Val): Val = eval(arg :: env, body)

case class PartialRenaming(cod: Level, dom: Level, map: Map[Int, Level]):
  def lift: PartialRenaming =
    PartialRenaming(cod + 1, dom + 1, map + (cod -> dom))
  def nextCod: Val = Val.Var(cod)

enum Raw:
  case U
  // _
  case Hole
  case Var(name: Name)
  case App(func: Raw, arg: Raw)
  case Lam(param: Name, body: Raw)
  case Pi(param: Name, ty: Raw, body: Raw)
  case Let(name: Name, ty: Raw, body: Raw, next: Raw)

enum Term:
  case U
  // ?0 | ?1 | ?2 | ...
  case Meta(metaID: MetaID)
  // meta with spine, ?0 spine
  case Inserted(metaID: MetaID)
  case Var(index: Index)
  case App(func: Term, arg: Term)
  case Lam(param: Name, body: Term)
  case Pi(param: Name, ty: Term, body: Term)
  case Let(name: Name, ty: Term, body: Term, next: Term)

enum Val:
  case U
  // ?0 spine
  case Flex(metaID: MetaID, spine: Spine)
  case Rigid(level: Level, spine: Spine)
  case Lam(param: Name, cl: Closure)
  case Pi(param: Name, ty: Val, cl: Closure)

  def apply(u: Val): Val = this match
    case Lam(param, cl)      => cl(u)
    case Rigid(level, spine) => Rigid(level, u :: spine)
    // append to spine like rigid case
    case Flex(metaID, spine) => Flex(metaID, u :: spine)
    case _                   => throw new Exception("impossible")

  // apply a whole spine
  def apply(sp: Spine): Val =
    sp.foldRight(this)((value, term) => term(value))

  // try to update a meta value to weak head normal form (WHNF) to be pattern matched
  // WHNF: suppose `S` is a constructor, S _ is WHNF, ?0 _ is not WHNF
  // WHNF doesn't care what the spine is
  def force: Val = this match
    case Flex(metaID, spine) => Meta.value(metaID)(spine)
    case _                   => this

object Val:
  def Var(level: Level): Val = Rigid(level, List())
  // fast meta creation like Rigid one
  def Meta(metaID: MetaID): Val = Flex(metaID, List())

def eval(env: Env, tm: Term): Val = tm match
  case Term.U =>
    Val.U
  // return updated meta with env applied
  case Term.Inserted(metaID) =>
    Meta.value(metaID)(env)
  // meta generated by `quote` should not be applied by env once again
  case Term.Meta(metaID) =>
    Meta.value(metaID)
  case Term.Var(index) =>
    env(index)
  case Term.App(func, arg) =>
    eval(env, func)(eval(env, arg))
  case Term.Lam(param, body) =>
    Val.Lam(param, Closure(env, body))
  case Term.Pi(param, ty, body) =>
    Val.Pi(param, eval(env, ty), Closure(env, body))
  case Term.Let(name, ty, body, next) =>
    eval(eval(env, body) :: env, next)

// update x first
def quote(envLen: Level, x: Val): Term =
  val quoteSp = (spine: Spine, initialTerm: Term) =>
    spine.foldRight(initialTerm)((value, term) =>
      Term.App(term, quote(envLen, value))
    )
  x.force match
    case Val.U =>
      Term.U
    // similar to the Rigid case
    case Val.Flex(metaID, spine) =>
      quoteSp(spine, Term.Meta(metaID))
    case Val.Rigid(level, spine) =>
      quoteSp(spine, Term.Var(envLen - level - 1))
    case Val.Lam(param, cl) =>
      Term.Lam(param, quote(envLen + 1, cl(Val.Var(envLen))))
    case Val.Pi(param, ty, cl) =>
      Term.Pi(
        param,
        quote(envLen, ty),
        quote(envLen + 1, cl(Val.Var(envLen)))
      )

def invert(envLen: Level, spine: Spine): PartialRenaming =
  spine.foldRight(PartialRenaming(envLen, 0, Map()))((value, pr) =>
    // get the latest meta solution
    value.force match
      case Val.Rigid(level, List()) =>
        PartialRenaming(pr.cod, pr.dom + 1, pr.map + (level -> pr.dom))
      // add a "ghost" renaming for let-bound variables
      // this is a naive solution, the one in elaboration-zoo
      // carries a bound-mask that avoids the problem
      case _ =>
        PartialRenaming(pr.cod, pr.dom + 1, pr.map)
  )

// update value first
def rename(lhs: MetaID, pr: PartialRenaming, value: Val): Term =
  val renameSp = (spine: Spine, initialTerm: Term) =>
    spine.foldRight(initialTerm)((value, term) =>
      Term.App(term, rename(lhs, pr, value))
    )
  value.force match
    case Val.U =>
      Term.U
    case Val.Flex(rhs, spine) =>
      // occurence check is added
      if rhs == lhs then throw new Exception(s"$rhs occurs in rhs")
      else renameSp(spine, Term.Meta(rhs))
    case Val.Rigid(level, spine) =>
      renameSp(spine, Term.Var(pr.dom - pr.map(level) - 1))
    case Val.Lam(param, cl) =>
      Term.Lam(param, rename(lhs, pr.lift, cl(pr.nextCod)))
    case Val.Pi(param, ty, cl) =>
      Term.Pi(
        param,
        rename(lhs, pr, ty),
        rename(lhs, pr.lift, cl(pr.nextCod))
      )

// due to occurence check, ID of renamed meta should be provided
def solve(lhs: MetaID, envLen: Level, sp: Spine, rhs: Val): Unit =
  val pr = invert(envLen, sp)
  val tm = rename(lhs, pr, rhs)
  Meta.solve(
    lhs,
    eval(
      List(),
      (0 until pr.dom).foldRight(tm)((lvl, term) => Term.Lam("x" + lvl, term))
    )
  )

// force parameters so that metas are not re-solved
def unify(envLen: Level, x: Val, y: Val): Unit =
  val unifySp = (x: Spine, y: Spine) =>
    x.foldRight(y)((vx, y) =>
      y match
        case vy :: rem => unify(envLen, vx, vy); rem
        case _         => throw new Exception("spine length differs")
    )
  (x.force, y.force) match
    case (Val.U, Val.U) =>
    case (Val.Flex(x, spx), Val.Flex(y, spy)) =>
      if x != y then throw new Exception(s"flex root differs: $x != $y")
      else unifySp(spx, spy)
    case (Val.Rigid(x, spx), Val.Rigid(y, spy)) =>
      if x != y then throw new Exception(s"rigid root differs: $x != $y")
      else unifySp(spx, spy)
    // when unifying, try to solve meta
    case (Val.Flex(id, spine), y) => solve(id, envLen, spine, y)
    case (x, Val.Flex(id, spine)) => solve(id, envLen, spine, x)
    case (Val.Lam(_, cl), y) =>
      val value = Val.Var(envLen)
      unify(envLen + 1, cl(value), y(value))
    case (x, Val.Lam(_, cl)) =>
      val value = Val.Var(envLen)
      unify(envLen + 1, x(value), cl(value))
    case (Val.Pi(_, ty1, cl1), Val.Pi(_, ty2, cl2)) =>
      val value = Val.Var(envLen)
      unify(envLen, ty1, ty2)
      unify(
        envLen + 1,
        cl1(value),
        cl2(value)
      )
    case _ => throw new Exception(s"unable to unify $x and $y")

def infer(ctx: Ctx, tm: Raw): (Term, Val) = tm match
  case Raw.U =>
    (Term.U, Val.U)
  // inferring type of hole creates two inserted metas, ?0 spine0 : ?1 spine1
  case Raw.Hole =>
    (Meta.fresh, eval(ctx.env, Meta.fresh))
  case Raw.Var(name) =>
    (Term.Var(ctx.envLen - ctx.getLevel(name) - 1), ctx.getType(name))
  case Raw.App(func, arg) =>
    val (funcTerm, funcType) = infer(ctx, func)
    // update value before pattern matching
    funcType.force match
      case Val.Pi(_, ty, cl) =>
        val argTerm = check(ctx, arg, ty)
        (Term.App(funcTerm, argTerm), cl(eval(ctx.env, argTerm)))
      case _ =>
        throw new Exception(s"$func is not a function")
  case Raw.Lam(param, body) =>
    // treat \x. t as \(x: _). t
    val metaVal = eval(ctx.env, Meta.fresh)
    val (bodyTerm, bodyType) = infer(ctx.add(param, metaVal), body)
    val tyClosure = Closure(ctx.env, quote(ctx.envLen + 1, bodyType))
    (Term.Lam(param, bodyTerm), Val.Pi(param, metaVal, tyClosure))
  case Raw.Pi(param, ty, body) =>
    val tyTerm = check(ctx, ty, Val.U)
    val tyVal = eval(ctx.env, tyTerm)
    val bodyTerm = check(ctx.add(param, tyVal), body, Val.U)
    (Term.Pi(param, tyTerm, bodyTerm), Val.U)
  case Raw.Let(name, ty, body, next) =>
    val tyTerm = check(ctx, ty, Val.U)
    val tyVal = eval(ctx.env, tyTerm)
    val bodyTerm = check(ctx, body, tyVal)
    val bodyVal = eval(ctx.env, bodyTerm)
    val (nextTerm, nextTy) = infer(ctx.add(name, bodyVal, tyVal), next)
    (Term.Let(name, tyTerm, bodyTerm, nextTerm), nextTy)

// desired type could be determined
def check(ctx: Ctx, tm: Raw, ty: Val): Term = (tm, ty.force) match
  // hole can be of any type, but it's a inserted meta, ?0 spine : Any
  case (Raw.Hole, _) =>
    Meta.fresh
  case (Raw.Lam(param, body), Val.Pi(_, ty, cl)) =>
    val value = ctx.nextVal
    val bodyVal = check(ctx.add(param, value, ty), body, cl(value))
    Term.Lam(param, bodyVal)
  case _ =>
    val (term, value) = infer(ctx, tm)
    unify(ctx.envLen, value, ty)
    term
